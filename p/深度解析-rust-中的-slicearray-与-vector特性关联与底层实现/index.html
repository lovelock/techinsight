<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="在 Rust 的集合类型体系中，Array（数组）、Vector（向量）与 Slice（切片）是承载连续数据的核心结构。三者看似都用于存储有序元素，却因底层设计、所有权模型与使用场景的差异，呈现出截然不同的特性。对于 Rust 开发者而言，理解它们的本质区别与关联，不仅是写出高效代码的关键，更是掌握 Rust 内存安全与性能平衡设计哲学的核心。本文将从底层实现出发，逐层剖析三者的特性、交互逻辑与适用场景，带你构建对 Rust 连续数据结构的深度认知。\n"><title>深度解析 Rust 中的 Slice、Array 与 Vector：特性、关联与底层实现</title><link rel=canonical href=https://techinsight.pages.dev/p/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-rust-%E4%B8%AD%E7%9A%84-slicearray-%E4%B8%8E-vector%E7%89%B9%E6%80%A7%E5%85%B3%E8%81%94%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/><link rel=stylesheet href=/scss/style.min.3c33722a11bfa97f07308377e860d658770fe60627a4c2b1b7d46497ac9c35c3.css><meta property='og:title' content="深度解析 Rust 中的 Slice、Array 与 Vector：特性、关联与底层实现"><meta property='og:description' content="在 Rust 的集合类型体系中，Array（数组）、Vector（向量）与 Slice（切片）是承载连续数据的核心结构。三者看似都用于存储有序元素，却因底层设计、所有权模型与使用场景的差异，呈现出截然不同的特性。对于 Rust 开发者而言，理解它们的本质区别与关联，不仅是写出高效代码的关键，更是掌握 Rust 内存安全与性能平衡设计哲学的核心。本文将从底层实现出发，逐层剖析三者的特性、交互逻辑与适用场景，带你构建对 Rust 连续数据结构的深度认知。\n"><meta property='og:url' content='https://techinsight.pages.dev/p/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-rust-%E4%B8%AD%E7%9A%84-slicearray-%E4%B8%8E-vector%E7%89%B9%E6%80%A7%E5%85%B3%E8%81%94%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/'><meta property='og:site_name' content='Tech In Sight'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='slice'><meta property='article:tag' content='array'><meta property='article:tag' content='vector'><meta property='article:published_time' content='2025-11-01T22:26:20+08:00'><meta property='article:modified_time' content='2025-11-01T22:26:20+08:00'><meta name=twitter:title content="深度解析 Rust 中的 Slice、Array 与 Vector：特性、关联与底层实现"><meta name=twitter:description content="在 Rust 的集合类型体系中，Array（数组）、Vector（向量）与 Slice（切片）是承载连续数据的核心结构。三者看似都用于存储有序元素，却因底层设计、所有权模型与使用场景的差异，呈现出截然不同的特性。对于 Rust 开发者而言，理解它们的本质区别与关联，不仅是写出高效代码的关键，更是掌握 Rust 内存安全与性能平衡设计哲学的核心。本文将从底层实现出发，逐层剖析三者的特性、交互逻辑与适用场景，带你构建对 Rust 连续数据结构的深度认知。\n"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_31786b9867641d1c.png width=300 height=280 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Tech In Sight</a></h1><h2 class=site-description>聊聊技术，聊聊人生</h2></div></header><ol class=menu-social><li><a href=https://github.com/lovelock target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#一array编译期确定大小的-静态容器>一、Array：编译期确定大小的 “静态容器”</a><ol><li><a href=#1-底层本质栈上的固定大小连续内存块>1. 底层本质：栈上的固定大小连续内存块</a></li><li><a href=#2-核心特性不可变性与所有权的-简单性>2. 核心特性：不可变性与所有权的 “简单性”</a></li><li><a href=#3-适用场景小规模固定大小的确定性数据>3. 适用场景：小规模、固定大小的确定性数据</a></li></ol></li><li><a href=#二vector堆上动态扩容的-可变集合>二、Vector：堆上动态扩容的 “可变集合”</a><ol><li><a href=#1-底层实现堆内存缓冲区--栈上元数据>1. 底层实现：堆内存缓冲区 + 栈上元数据</a></li><li><a href=#2-核心特性动态性所有权与内存安全>2. 核心特性：动态性、所有权与内存安全</a></li><li><a href=#3-适用场景大规模动态变化的连续数据>3. 适用场景：大规模、动态变化的连续数据</a></li></ol></li><li><a href=#三slice跨越容器的-数据视图>三、Slice：跨越容器的 “数据视图”</a><ol><li><a href=#1-底层本质指针--长度的-轻量级视图>1. 底层本质：指针 + 长度的 “轻量级视图”</a></li><li><a href=#2-核心特性无所有权借用约束与通用性>2. 核心特性：无所有权、借用约束与通用性</a></li><li><a href=#3-适用场景泛化连续数据操作与安全访问>3. 适用场景：泛化连续数据操作与安全访问</a></li></ol></li><li><a href=#四三者的关联与差异一张表看懂核心区别>四、三者的关联与差异：一张表看懂核心区别</a></li><li><a href=#五实践指南如何选择合适的连续数据结构>五、实践指南：如何选择合适的连续数据结构？</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/rust/>Rust</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-rust-%E4%B8%AD%E7%9A%84-slicearray-%E4%B8%8E-vector%E7%89%B9%E6%80%A7%E5%85%B3%E8%81%94%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/>深度解析 Rust 中的 Slice、Array 与 Vector：特性、关联与底层实现</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Nov 01, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 11 分钟</time></div></footer></div></header><section class=article-content><p>在 Rust 的集合类型体系中，Array（数组）、Vector（向量）与 Slice（切片）是承载连续数据的核心结构。三者看似都用于存储有序元素，却因底层设计、所有权模型与使用场景的差异，呈现出截然不同的特性。对于 Rust 开发者而言，理解它们的本质区别与关联，不仅是写出高效代码的关键，更是掌握 Rust 内存安全与性能平衡设计哲学的核心。本文将从底层实现出发，逐层剖析三者的特性、交互逻辑与适用场景，带你构建对 Rust 连续数据结构的深度认知。</p><h2 id=一array编译期确定大小的-静态容器><a href=#%e4%b8%80array%e7%bc%96%e8%af%91%e6%9c%9f%e7%a1%ae%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84-%e9%9d%99%e6%80%81%e5%ae%b9%e5%99%a8 class=header-anchor></a>一、Array：编译期确定大小的 “静态容器”</h2><p>Array（数组）是 Rust 中最基础的连续数据结构，其设计核心是 “编译期固定大小”，这一特性决定了它的内存布局、所有权模型与使用边界。</p><h3 id=1-底层本质栈上的固定大小连续内存块><a href=#1-%e5%ba%95%e5%b1%82%e6%9c%ac%e8%b4%a8%e6%a0%88%e4%b8%8a%e7%9a%84%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e5%9d%97 class=header-anchor></a>1. 底层本质：栈上的固定大小连续内存块</h3><p>在 Rust 中，Array 的类型表示为<code>[T; N]</code>，其中<code>T</code>是元素类型，<code>N</code>是一个<strong>非负整数常量</strong>（必须在编译期确定）。其底层实现是一段连续的内存空间，直接分配在栈上（而非堆上），元素紧密排列，无额外内存开销（如长度、容量指针等）。例如，<code>let arr: [i32; 3] = [1, 2, 3];</code>在栈上的内存布局为 3 个<code>i32</code>类型的连续空间，总大小为<code>3 * 4 = 12</code>字节（假设<code>i32</code>为 4 字节）。</p><p>这种 “栈上固定大小” 的设计带来两个关键特性：</p><ul><li><p><strong>内存高效</strong>：无额外元数据，内存利用率达到 100%，适合存储小规模、固定数量的数据（如 RGB 颜色值<code>[u8; 3]</code>、矩阵的行<code>[f64; 4]</code>）。</p></li><li><p><strong>编译期安全检查</strong>：由于大小固定，编译器可在编译期验证数组访问的合法性。例如，<code>arr[5]</code>会直接触发编译错误（索引超出数组长度 3），避免了 C/C++ 中数组越界的运行时风险。</p></li></ul><h3 id=2-核心特性不可变性与所有权的-简单性><a href=#2-%e6%a0%b8%e5%bf%83%e7%89%b9%e6%80%a7%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%e4%b8%8e%e6%89%80%e6%9c%89%e6%9d%83%e7%9a%84-%e7%ae%80%e5%8d%95%e6%80%a7 class=header-anchor></a>2. 核心特性：不可变性与所有权的 “简单性”</h3><p>Array 的特性与其 “静态大小” 的设计强绑定，主要体现在不可变性、所有权与方法支持上：</p><ul><li><p><strong>默认不可变，显式可变</strong>：与 Rust 中变量默认不可变一致，Array 默认无法修改元素（如<code>arr[0] = 4</code>会报错），需通过<code>mut</code>关键字显式声明可变数组：<code>let mut arr: [i32; 3] = [1, 2, 3]; arr[0] = 4;</code>。但需注意，<strong>数组的大小始终不可变</strong>，即使是可变数组，也无法追加、删除元素或改变长度。</p></li><li><p><strong>所有权的 “值语义”</strong>：Array 是 “拥有型类型”（Owned Type），但其所有权转移遵循 “值语义”—— 当数组被赋值给新变量或传递给函数时，会触发<strong>完整的数据复制</strong>（而非引用传递）。例如：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>arr1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>arr2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr1</span><span class=p>;</span><span class=w> </span><span class=c1>// 复制 arr1 的所有元素到 arr2，arr1 仍可使用（因 i32 实现 Copy 特性）
</span></span></span></code></pre></td></tr></table></div></div><p>若数组元素类型未实现<code>Copy</code>特性（如<code>String</code>），则赋值后原数组会失去所有权（无法再使用），这与 Rust 基本的所有权规则一致。</p><ul><li><strong>有限的方法支持</strong>：由于大小固定，Array 仅提供少量基础方法（如<code>len()</code>获取长度、<code>iter()</code>生成迭代器），不支持动态集合的操作（如<code>push()</code>、<code>pop()</code>）。若需更灵活的操作，需先将其转换为 Slice 或 Vector。</li></ul><h3 id=3-适用场景小规模固定大小的确定性数据><a href=#3-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e5%b0%8f%e8%a7%84%e6%a8%a1%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e7%a1%ae%e5%ae%9a%e6%80%a7%e6%95%b0%e6%8d%ae class=header-anchor></a>3. 适用场景：小规模、固定大小的确定性数据</h3><p>Array 的设计决定了它更适合存储 “数量已知且固定” 的小规模数据，典型场景包括：</p><ul><li><p>存储固定维度的数据（如 2D 坐标<code>[f64; 2]</code>、RGBA 颜色<code>[u8; 4]</code>）。</p></li><li><p>作为函数参数传递少量固定数据（如配置项、状态码列表），避免堆内存分配开销。</p></li><li><p>作为底层容器，为 Slice 或 Vector 提供初始数据（如<code>let vec: Vec&lt;i32> = arr.into();</code>将数组转换为向量）。</p></li></ul><h2 id=二vector堆上动态扩容的-可变集合><a href=#%e4%ba%8cvector%e5%a0%86%e4%b8%8a%e5%8a%a8%e6%80%81%e6%89%a9%e5%ae%b9%e7%9a%84-%e5%8f%af%e5%8f%98%e9%9b%86%e5%90%88 class=header-anchor></a>二、Vector：堆上动态扩容的 “可变集合”</h2><p>Vector（向量）是 Rust 中最常用的动态连续数据结构，其设计核心是 “堆上存储 + 动态扩容”，弥补了 Array 大小固定的局限性，同时保持了连续内存的访问效率。</p><h3 id=1-底层实现堆内存缓冲区--栈上元数据><a href=#1-%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%86%85%e5%ad%98%e7%bc%93%e5%86%b2%e5%8c%ba--%e6%a0%88%e4%b8%8a%e5%85%83%e6%95%b0%e6%8d%ae class=header-anchor></a>1. 底层实现：堆内存缓冲区 + 栈上元数据</h3><p>Vector 的类型表示为<code>Vec&lt;T></code>，其底层由两部分组成：</p><ul><li><p><strong>栈上元数据</strong>：包含三个字段 ——<code>ptr</code>（指向堆内存缓冲区的指针）、<code>len</code>（当前存储的元素数量）、<code>cap</code>（缓冲区的总容量，即最多可存储的元素数量），总大小为<code>3 * usize</code>（在 64 位系统上为 24 字节）。</p></li><li><p><strong>堆上缓冲区</strong>：一段连续的内存空间，用于存储实际的<code>T</code>类型元素，缓冲区大小由<code>cap</code>决定，且会根据元素的添加 / 删除自动扩容或收缩（按需调整）。</p></li></ul><p>例如，<code>let mut vec: Vec&lt;i32> = Vec::with_capacity(3); vec.push(1); vec.push(2);</code>的底层状态为：</p><ul><li><p>栈上元数据：<code>ptr</code>指向堆上 3 个<code>i32</code>大小的缓冲区，<code>len = 2</code>，<code>cap = 3</code>。</p></li><li><p>堆上缓冲区：前两个位置存储<code>1</code>和<code>2</code>，第三个位置空闲（待填充）。</p></li></ul><p>当<code>len</code>达到<code>cap</code>（如继续<code>vec.push(3); vec.push(4);</code>）时，Vector 会触发<strong>扩容机制</strong>：</p><ol><li><p>计算新容量（通常为当前容量的 2 倍，避免频繁扩容）。</p></li><li><p>在堆上分配一块新的、更大的缓冲区。</p></li><li><p>将旧缓冲区的元素复制到新缓冲区。</p></li><li><p>释放旧缓冲区的内存，更新<code>ptr</code>和<code>cap</code>字段。</p></li></ol><p>这种扩容机制保证了<code>push()</code>操作的平均时间复杂度为 O (1)，但需注意：扩容时的复制操作会带来短暂的性能开销，且若元素类型未实现<code>Copy</code>特性，复制过程会触发所有权转移（可能影响性能）。</p><h3 id=2-核心特性动态性所有权与内存安全><a href=#2-%e6%a0%b8%e5%bf%83%e7%89%b9%e6%80%a7%e5%8a%a8%e6%80%81%e6%80%a7%e6%89%80%e6%9c%89%e6%9d%83%e4%b8%8e%e5%86%85%e5%ad%98%e5%ae%89%e5%85%a8 class=header-anchor></a>2. 核心特性：动态性、所有权与内存安全</h3><p>Vector 的特性围绕 “动态管理连续内存” 展开，同时遵循 Rust 的内存安全规则：</p><ul><li><p><strong>完全动态的元素操作</strong>：支持<code>push()</code>（尾部添加）、<code>pop()</code>（尾部删除）、<code>insert()</code>（指定位置插入）、<code>remove()</code>（指定位置删除）等操作，可灵活调整元素数量。需注意，<code>insert()</code>和<code>remove()</code>会导致指定位置后的元素 “平移”（内存复制），时间复杂度为 O (n)，因此不适合频繁在中间位置修改数据（此时应优先选择<code>LinkedList</code>或<code>VecDeque</code>）。</p></li><li><p><strong>所有权的 “容器语义”</strong>：Vector 拥有其堆上缓冲区的所有权，同时也拥有所有元素的所有权。当 Vector 超出作用域时，会先自动销毁所有元素（调用元素的<code>Drop</code>方法），再释放堆上缓冲区的内存，彻底避免内存泄漏。例如，<code>Vec&lt;String></code>被销毁时，会先逐个销毁内部的<code>String</code>（释放其堆内存），再释放 Vector 自身的堆缓冲区。</p></li><li><p><strong>切片化与借用规则</strong>：Vector 可通过<code>&amp;vec</code>或<code>vec.as_slice()</code>转换为<code>&[T]</code>（Slice），此时会生成一个指向 Vector 堆缓冲区的 “视图”，且遵循 Rust 的借用规则 —— 若存在<code>&[T]</code>（不可变切片），则 Vector 无法被修改（避免切片指向无效数据）；若存在<code>&amp;mut [T]</code>（可变切片），则 Vector 无法被其他方式借用（避免数据竞争）。</p></li></ul><h3 id=3-适用场景大规模动态变化的连续数据><a href=#3-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e5%a4%a7%e8%a7%84%e6%a8%a1%e5%8a%a8%e6%80%81%e5%8f%98%e5%8c%96%e7%9a%84%e8%bf%9e%e7%bb%ad%e6%95%b0%e6%8d%ae class=header-anchor></a>3. 适用场景：大规模、动态变化的连续数据</h3><p>Vector 凭借动态性与高效性，成为 Rust 中处理连续数据的 “首选工具”，典型场景包括：</p><ul><li><p>存储数量不确定的数据（如用户输入列表、日志条目、网络请求响应体）。</p></li><li><p>作为动态数组使用，替代其他语言中的<code>ArrayList</code>或<code>std::vector</code>（C++）。</p></li><li><p>作为底层容器，为其他数据结构提供连续内存支持（如<code>HashMap</code>的桶数组、<code>VecDeque</code>的环形缓冲区）。</p></li></ul><h2 id=三slice跨越容器的-数据视图><a href=#%e4%b8%89slice%e8%b7%a8%e8%b6%8a%e5%ae%b9%e5%99%a8%e7%9a%84-%e6%95%b0%e6%8d%ae%e8%a7%86%e5%9b%be class=header-anchor></a>三、Slice：跨越容器的 “数据视图”</h2><p>Slice（切片）是 Rust 中最特殊的连续数据结构，其设计核心是 “无所有权的视图”—— 它不存储数据，仅指向其他容器（Array、Vector、甚至另一个 Slice）中的一段连续数据，是连接 Array 与 Vector 的 “桥梁”。</p><h3 id=1-底层本质指针--长度的-轻量级视图><a href=#1-%e5%ba%95%e5%b1%82%e6%9c%ac%e8%b4%a8%e6%8c%87%e9%92%88--%e9%95%bf%e5%ba%a6%e7%9a%84-%e8%bd%bb%e9%87%8f%e7%ba%a7%e8%a7%86%e5%9b%be class=header-anchor></a>1. 底层本质：指针 + 长度的 “轻量级视图”</h3><p>Slice 的类型表示为<code>&[T]</code>（不可变切片）或<code>&amp;mut [T]</code>（可变切片），其底层是一个 “胖指针”（Fat Pointer），包含两个字段：</p><ul><li><p><code>ptr</code>：指向目标容器中连续数据的起始位置的指针（与容器数据的内存地址一致）。</p></li><li><p><code>len</code>：切片包含的元素数量（<code>usize</code>类型，需小于等于目标容器的长度）。</p></li></ul><p>例如：</p><ul><li><p>对 Array<code>let arr = [1, 2, 3, 4];</code>取切片<code>let slice = &amp;arr[1..3];</code>，切片的<code>ptr</code>指向<code>arr[1]</code>的地址，<code>len = 2</code>（包含<code>2</code>和<code>3</code>）。</p></li><li><p>对 Vector<code>let vec = vec![1, 2, 3, 4];</code>取切片<code>let slice = &amp;vec[2..];</code>，切片的<code>ptr</code>指向<code>vec</code>堆缓冲区中<code>3</code>的地址，<code>len = 2</code>（包含<code>3</code>和<code>4</code>）。</p></li></ul><p>Slice 的 “无所有权” 特性意味着：</p><ul><li><p>切片不管理数据的生命周期，数据的生命周期由其指向的容器（Array/Vector）决定。</p></li><li><p>切片的生命周期不能超过目标容器的生命周期（否则会出现 “悬垂切片”，触发编译器错误）。例如：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>slice</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>arr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>slice</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>arr</span><span class=p>;</span><span class=w> </span><span class=c1>// 错误：arr 的生命周期在块结束后结束，slice 会成为悬垂引用
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=2-核心特性无所有权借用约束与通用性><a href=#2-%e6%a0%b8%e5%bf%83%e7%89%b9%e6%80%a7%e6%97%a0%e6%89%80%e6%9c%89%e6%9d%83%e5%80%9f%e7%94%a8%e7%ba%a6%e6%9d%9f%e4%b8%8e%e9%80%9a%e7%94%a8%e6%80%a7 class=header-anchor></a>2. 核心特性：无所有权、借用约束与通用性</h3><p>Slice 的特性完全围绕 “视图” 角色展开，是 Rust 实现 “泛型连续数据操作” 的关键：</p><ul><li><p><strong>无所有权与不可复制性</strong>：Slice 不拥有数据，因此既不支持<code>Copy</code>特性（无法直接赋值复制），也不支持<code>Clone</code>特性（除非元素类型支持<code>Clone</code>，且需显式调用<code>clone()</code>复制数据，而非切片本身）。切片的传递本质是 “引用传递”，仅复制胖指针（开销极小，64 位系统上为 16 字节），不复制底层数据。</p></li><li><p><strong>严格的借用规则</strong>：作为引用类型，Slice 遵循 Rust 的借用规则：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>slice1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>vec</span><span class=p>[</span><span class=o>..</span><span class=p>];</span><span class=w> </span><span class=c1>// 不可变切片
</span></span></span><span class=line><span class=cl><span class=c1>// let slice2 = &amp;mut vec[..]; // 错误：不可变切片与可变切片不能共存
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>不可变切片（<code>&[T]</code>）：允许同时存在多个不可变切片，但禁止同时存在可变切片或对容器的可变借用（避免数据竞争）。</p></li><li><p>可变切片（<code>&amp;mut [T]</code>）：禁止同时存在其他任何切片或借用（可变引用独占数据），确保修改操作的安全性。</p><p>例如：</p></li></ul><ul><li><strong>泛型操作的 “统一接口”</strong>：由于 Slice 可从 Array 和 Vector 中生成，且提供了丰富的通用方法（如<code>sort()</code>、<code>iter()</code>、<code>split()</code>、<code>join()</code>），它成为了 Rust 中 “处理连续数据” 的统一接口。例如，一个接受<code>&[T]</code>参数的函数，既能处理 Array 的切片，也能处理 Vector 的切片，无需为两种容器单独实现：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 计算切片中所有元素的和（泛型函数，支持 Array 和 Vector 的切片）
</span></span></span><span class=line><span class=cl><span class=k>fn</span> <span class=nf>sum_slice</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>std</span>::<span class=n>ops</span>::<span class=n>Add</span><span class=o>&lt;</span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Default</span><span class=o>&gt;</span><span class=p>(</span><span class=n>slice</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>T</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>slice</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>fold</span><span class=p>(</span><span class=n>T</span>::<span class=n>default</span><span class=p>(),</span><span class=w> </span><span class=o>|</span><span class=n>acc</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=n>acc</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>arr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>6</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Array sum: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>sum_slice</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arr</span><span class=p>));</span><span class=w> </span><span class=c1>// 输出 6
</span></span></span><span class=line><span class=cl><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Vector sum: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>sum_slice</span><span class=p>(</span><span class=o>&amp;</span><span class=n>vec</span><span class=p>));</span><span class=w> </span><span class=c1>// 输出 15
</span></span></span></code></pre></td></tr></table></div></div><h3 id=3-适用场景泛化连续数据操作与安全访问><a href=#3-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e6%b3%9b%e5%8c%96%e8%bf%9e%e7%bb%ad%e6%95%b0%e6%8d%ae%e6%93%8d%e4%bd%9c%e4%b8%8e%e5%ae%89%e5%85%a8%e8%ae%bf%e9%97%ae class=header-anchor></a>3. 适用场景：泛化连续数据操作与安全访问</h3><p>Slice 的 “视图” 角色使其在以下场景中不可或缺：</p><ul><li><p><strong>函数参数的泛化</strong>：当函数需要处理 “连续数据” 但不关心数据的具体容器类型（Array/Vector）时，使用<code>&[T]</code>作为参数，提高函数的通用性（如上述<code>sum_slice</code>函数）。</p></li><li><p><strong>安全的部分数据访问</strong>：无需复制数据，即可访问容器中的部分元素（如从 Vector 中提取子数组、处理文件的某段字节数据），减少内存开销。</p></li><li><p><strong>与其他数据结构的交互</strong>：许多 Rust 标准库函数（如<code>std::io::Read::read()</code>、<code>std::fs::read_to_string()</code>）返回或接受 Slice，作为数据传输的 “中间载体”。</p></li></ul><h2 id=四三者的关联与差异一张表看懂核心区别><a href=#%e5%9b%9b%e4%b8%89%e8%80%85%e7%9a%84%e5%85%b3%e8%81%94%e4%b8%8e%e5%b7%ae%e5%bc%82%e4%b8%80%e5%bc%a0%e8%a1%a8%e7%9c%8b%e6%87%82%e6%a0%b8%e5%bf%83%e5%8c%ba%e5%88%ab class=header-anchor></a>四、三者的关联与差异：一张表看懂核心区别</h2><p>为了更清晰地对比 Array、Vector 与 Slice 的核心差异，我们通过下表从底层存储、大小特性、所有权、性能等维度进行总结：</p><div class=table-wrapper><table><thead><tr><th>特性维度</th><th>Array（<code>[T; N]</code>）</th><th>Vector（<code>Vec&lt;T></code>）</th><th>Slice（<code>&[T]</code>/<code>&amp;mut [T]</code>）</th></tr></thead><tbody><tr><td><strong>底层存储位置</strong></td><td>栈（Stack）</td><td>元数据在栈，数据在堆（Heap）</td><td>无存储，指向其他容器的内存（栈 / 堆）</td></tr><tr><td><strong>大小特性</strong></td><td>编译期固定（<code>N</code>为常量）</td><td>运行期动态变化（支持扩容 / 收缩）</td><td>运行期确定（由切片范围决定）</td></tr><tr><td><strong>所有权</strong></td><td>拥有数据（值语义，赋值会复制）</td><td>拥有数据（容器语义，管理堆内存）</td><td>无所有权（仅作为数据视图）</td></tr><tr><td><strong>内存开销</strong></td><td>无额外开销（仅存储元素）</td><td>栈上 3 个<code>usize</code>（元数据）</td><td>栈上 2 个<code>usize</code>（胖指针）</td></tr><tr><td><strong>元素修改</strong></td><td>支持（需<code>mut</code>），但大小不可变</td><td>支持动态添加 / 删除 / 修改</td><td>不可变切片禁止修改，可变切片支持修改</td></tr><tr><td><strong>生命周期</strong></td><td>与变量作用域一致（栈内存自动释放）</td><td>与变量作用域一致（堆内存自动释放）</td><td>依赖目标容器的生命周期（不可独立存在）</td></tr><tr><td><strong>典型方法</strong></td><td><code>len()</code>、<code>iter()</code></td><td><code>push()</code>、<code>pop()</code>、<code>insert()</code>、<code>sort()</code></td><td><code>sort()</code>、<code>split()</code>、<code>join()</code>、<code>iter()</code></td></tr><tr><td><strong>适用场景</strong></td><td>小规模、固定大小数据</td><td>大规模、动态变化数据</td><td>泛化连续数据操作、部分数据访问</td></tr></tbody></table></div><h2 id=五实践指南如何选择合适的连续数据结构><a href=#%e4%ba%94%e5%ae%9e%e8%b7%b5%e6%8c%87%e5%8d%97%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e8%bf%9e%e7%bb%ad%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 class=header-anchor></a>五、实践指南：如何选择合适的连续数据结构？</h2><p>在实际开发中，选择 Array、Vector 还是 Slice，需结合数据规模、变化频率、内存开销等因素综合判断，以下是具体的选择指南：</p><ol><li><strong>优先选择 Array 的场景</strong>：</li></ol><ul><li><p>数据数量在编译期已知且固定（如 RGB 颜色、坐标点）。</p></li><li><p>数据规模较小（避免栈溢出，栈大小通常有限，如 Linux 默认栈大小为 8MB）。</p></li><li><p>需极致的内存效率（无额外元数据开销）或避免堆内存分配（如嵌入式开发、高性能场景）。</p></li></ul><ol><li><strong>优先选择 Vector 的场景</strong>：</li></ol><ul><li><p>数据数量在运行期确定或动态变化（如用户输入列表、日志集合）。</p></li><li><p>数据规模较大（堆内存可支持更大的存储容量）。</p></li><li><p>需频繁添加 / 删除元素（尤其是尾部操作，<code>push()</code>/<code>pop()</code>效率高）。</p></li></ul><ol><li><strong>优先选择 Slice 的场景</strong>：</li></ol><ul><li>编写泛化函数（需同时支持 Array 和 Vector 作为输入）。</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/slice/>Slice</a>
<a href=/tags/array/>Array</a>
<a href=/tags/vector/>Vector</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E5%AD%97%E8%8A%82%E5%BA%8F%E9%9A%90%E8%97%8F%E5%9C%A8cpu%E6%B7%B1%E5%A4%84%E7%9A%84%E5%AD%98%E5%82%A8%E5%AF%86%E7%A0%81%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0rust%E5%AE%9E%E8%B7%B5/><div class=article-details><h2 class=article-title>字节序：隐藏在CPU深处的“存储密码”，从原理到Rust实践</h2></div></a></article><article><a href=/p/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-rust-%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8E%E5%AD%97%E8%8A%82%E6%B5%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/><div class=article-details><h2 class=article-title>深度解析 Rust 中读取文本文件与字节流（二进制文件）的核心注意事项</h2></div></a></article><article><a href=/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-rust-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%85%B3%E7%B3%BB%E5%8C%BA%E5%88%AB%E4%B8%8E-0x00-%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/><div class=article-details><h2 class=article-title>深入解析 Rust 中的字符串类型：关系、区别与 '0x00' 处理方案</h2></div></a></article><article><a href=/p/rust-%E4%B8%AD%E7%9A%84-for...in-%E5%BE%AA%E7%8E%AF%E7%AE%80%E6%B4%81%E8%BF%AD%E4%BB%A3%E7%9A%84%E8%89%BA%E6%9C%AF/><div class=article-details><h2 class=article-title>Rust 中的 `for...in` 循环：简洁迭代的艺术</h2></div></a></article><article><a href=/p/%E4%BB%8Ec-%E5%92%8Crust%E8%81%8A%E8%81%8Araii/><div class=article-details><h2 class=article-title>从C++和Rust聊聊RAII</h2></div></a></article></div></div></aside><div class=disqus-container></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2014 -
2026 Tech In Sight</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>